/**
 * @author Louis
 */

/* This var will hold stuff that doesn't really change so we can save time and not go crazy. */
var requestParam = {
		urlBase:     "https://api.twitter.com/1.1/statuses/",
		sigMeth:     "HMAC-SHA1",
		version:     "1.0",
		timeStamp:   function() {
		    return Math.floor((new Date).getTime() / 1000);
	        }
};

/* TwitterCall is a variable that we're going to use to call Twitter. It will contain
 * all the functions that will handle all the different API calls we'll need to make.
 * 
 * Any variables that need to be passed in will be specified. All calls need a callback
 * so that we can know what to do once the call is complete. They will also probably
 * need a doc of args, but that could be empty. */
var TwitterCall;
if (TwitterCall == null) TwitterCall = {};


TwitterCall.hometimeline = function(args,callback,onfail) {
	
	if (onfail == null) onfail = function(transport){
		TwitterCall.failHandler(transport);
	};
	
	var url = requestParam.urlBase + "home_timeline.json";
	var header = TwitterFormat.getHeader("GET",url,args);
	
	TwitterCall.ajaxRequest(url,"GET",header,args,callback,onfail);

};
TwitterCall.ajaxRequest = function (url,method,authHeader,args,callback,onfail){
	var ajaxArgs = {
			method: method,
			encoding: "UTF-8",
			parameters: args,
			requestHeaders: {Authorization: authHeader,
				Accept: "application/json"},
				onSuccess: callback,
				onFailure: onfail,
	}
	new Ajax.Request(url, ajaxArgs);
};
TwitterCall.mentionstimeline = function(args,callback,onfail) {
	
	if (onfail == null) onfail = function(transport){
		TwitterCall.failHandler(transport);
	};
	
	var url = requestParam.urlBase + "mentions_timeline.json";
	var header = TwitterFormat.getHeader("GET",url,args);
	
	TwitterCall.ajaxRequest(url,"GET",header,args,callback,onfail);
}
TwitterCall.getResponse = function(transport){
	var response = transport.responseJSON;
	response = TweetBuild.timeline(response);
	return response;
};
TwitterCall.failHandler = function(transport){
	var response = transport.responseJSON || "No response text.";
	//Mojo.Log.info("ERROR:",response.errors[0].code,response.errors[0].message);
	Mojo.Controller.getAppController().showBanner("Error: " + response.errors[0].message,{source: "notification"},"auroris");
};

/* TwitterFormat is a function that should be exclusively called by TwitterCall. It's to help
 * format the variables that need to be percent encoded, hashed, base64'd, whatever. Ideally,
 * we will call it with all the particulars:
 * 
 * address
 * method
 * encoding
 * 
 * and then the things that become the Authorization header:
 * consumer key
 * nonce (actually this will be calculated on the fly, but we could pass in the function?)
 * signature (this will also need to be calculated on the fly)
 * signature method
 * timestamp
 * token
 * version 
 * 
 * All these will be passed in as args into probably just one function, to produce the final
 * thing we send. That one function will call other functions of TwitterFormat, to produce
 * percent encoded strings and whatnot.
 * 
 * */
var TwitterFormat;
if (TwitterFormat == null) TwitterFormat = {};

TwitterFormat.percentEncode = function (s) {
	if (s == null){
		return "";
	}
	if (s instanceof Array) {
		var e = "";
		for (var i = 0; i < s.length; i++) {
			if (e != "") e += "&";
			e +=TwitterFormat.percentEncode(s[i]);
		}
		return e;
	}
	s = encodeURIComponent(s);

	s = s.replace(/\!/g, "%21");
	s = s.replace(/\*/g, "%2A");
	s = s.replace(/\'/g, "%27");
	s = s.replace(/\(/g, "%28");
	s = s.replace(/\)/g, "%29");
	return s;
};
TwitterFormat.generateNonce = function (){
	/* Here we will generate a string of random characters to be used as the Nonce.
	 * We will generate the string one random character at a time. According to Twitter:
	 * 
	 * "The oauth_nonce parameter is a unique token your application should generate for 
	 * each unique request. Twitter will use this value to determine whether a request 
	 * has been submitted multiple times. The value for this request was generated by 
	 * base64 encoding 32 bytes of random data, and stripping out all non-word characters,
	 * but any approach which produces a relatively random alphanumeric string should be 
	 * OK here."
	 * 
	 * We will be doing the same thing, more or less, except we'll eliminate the need for
	 * stripping out non-word characters by using an input string whose length is
	 * divisible by 3, so no equal signs will be appended to the end (which is done to
	 * signify there are leftover bits). */
	
	var s;
	var charString = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=";
	var charNum;
	for (var i = 0; i < 30 ; i++){
		charNum = Math.floor(Math.random() * charString.length);
		if (s == null) s = charString[charNum];
		else s += charString[charNum];
	};
	//Mojo.Log.info("Nonce:",s);
	//Mojo.Log.info("PEncode",TwitterFormat.percentEncode(s));
	s = btoa(s);
	//Mojo.Log.info("Encoded",s);
	return s;
};
TwitterFormat.getSignature = function(method,url,args){
	var sigBaseString = method + "&";
	sigBaseString += TwitterFormat.percentEncode(url) + "&";
	
	var keylist = [];
	for (var key in args){
		keylist.push(key);
	};
	keylist.sort();
	var sigBaseParams;
	for (var i = 0; i < keylist.length; i++){
		if (sigBaseParams == null) sigBaseParams = TwitterFormat.percentEncode(keylist[i]);
		else sigBaseParams += "&" + TwitterFormat.percentEncode(keylist[i]);
		sigBaseParams += "=" + TwitterFormat.percentEncode(args[keylist[i]]);
	};
	//Mojo.Log.info("Params String:",sigBaseParams);
	
	sigBaseString += TwitterFormat.percentEncode(sigBaseParams);
	//Mojo.Log.info("whole thing:",sigBaseString);
	
	var signingKey = TwitterFormat.percentEncode(Config.consumerSecret) +
	                 "&" + TwitterFormat.percentEncode(User.secret);

	var signatureHash = CryptoJS.HmacSHA1(sigBaseString,signingKey);
	signatureHash = signatureHash.toString();
	signatureHash = signatureHash.toUpperCase();
	
	var oauthSig = base64Convert(signatureHash);
	
	//Mojo.Log.info("oauth signature:",oauthSig);
	
	return oauthSig;
	
};
TwitterFormat.getHeader = function(method,url,args){
	/* The header string is comprised of 7 components that should never change:
	 * 
	 * 1. consumer key
	 * 2. nonce
	 * 3. signature
	 * 4. signature method
	 * 5. timestamp
	 * 6. token
	 * 7. version
	 * 
	 * These should be part of ANY request to Twitter. */

	var timestamp = requestParam.timeStamp();
	var oauth = {
			"oauth_consumer_key" : Config.consumerKey,
			"oauth_nonce" : TwitterFormat.generateNonce(),
			"oauth_signature_method" : requestParam.sigMeth,
			"oauth_timestamp" : timestamp,
			"oauth_token" : User.token,
			"oauth_version" : requestParam.version,
	};
	for (var key in oauth){
		args[key] = oauth[key];
	};
	
	oauth.oauth_signature = TwitterFormat.getSignature(method, url, args);
	
	var header = "OAuth ";
	for (var key in oauth) {
		if (header != "OAuth ") header += ', ';
		header += TwitterFormat.percentEncode(key) + '=' + '"'
				+ TwitterFormat.percentEncode(oauth[key]) + '"';
	};
	
	return header;
};

var TweetBuild;
if (TweetBuild == null) TweetBuild = {};

TweetBuild.timeline = function(timeline){
	
	Mojo.Log.info("size",timeline.length);
	
	for (var i = 0; i < timeline.length; i++){
		//Mojo.Log.info("outer loop",i,timeline[i].user.screen_name);
		/* Modify text and user info for retweets so they appear to be from OP */
		if ("retweeted_status" in timeline[i]){
			//Mojo.Log.info("we found one!",i)
			timeline[i].retweeted_by = timeline[i].user;
			timeline[i].retweeted_by.rt_message = "retweeted by";   // Adding this for sake of Timeline
			timeline[i].user = timeline[i].retweeted_status.user;
			timeline[i].text = timeline[i].retweeted_status.text;
			timeline[i].created_at = timeline[i].retweeted_status.created_at;
			timeline[i].entities = timeline[i].retweeted_status.entities;
		};
		/* Format the tweet for timeline appearance with HTML, which will be purely cosmetic */
		timeline[i].text = TweetBuild.timelinetweet(timeline[i].text,timeline[i].entities);
		timeline[i].created_at_format = relativeTime.simple(timeline[i].created_at);
		timeline[i].source = TweetBuild.stripSourceHTML(timeline[i].source);
		//Mojo.Log.info(timeline[i].text);
	};
	
	return timeline;
};
TweetBuild.timelinetweet = function(text,entities){
	
	var replaceList = [];
	
	for (var key in entities){
		for (var i = 0; i < entities[key].length; i++){
			var start = entities[key][i].indices[0];
			var end   = entities[key][i].indices[1];
			var replace = text.substring(start,end);
			var replaceWith = "<span class=\"tweet-special\">" + replace + "</span>";
			replaceList.push({
				"start" : start,
				"end" : end,
				"replace" : replace,
				"replaceWith" : replaceWith
			});
		};
	};
	
	for (var i = 0; i < replaceList.length; i++){
		text = text.replace(replaceList[i].replace,replaceList[i].replaceWith);
	}
	
	text = text.replace(/\n/g,"<br />");
	
	return text;
};
TweetBuild.refreshTStamps = function(timeline){
	for (var i = 0; i < timeline.length; i++){
		timeline[i].created_at_format = relativeTime.simple(timeline[i].created_at);
	};
	return timeline;
};
TweetBuild.stripSourceHTML = function (source){
	var start = source.indexOf(">") + 1;
	var end = source.lastIndexOf("<");
	
	var replace = source.substring(start,end);
	replace = "<span class=\"tweet-source\">" + replace + "</span>";
	
	return replace;
};